# Execution Context

* JavaScript의 동작 원리를 담고 있는 핵심 개념
* this, 호이스팅, 클로저, 비동기를 이해 할 수 있는 기반

## 소스코드의 타입

* ECMASCript 사양은 Source Code를 4가지 타입으로 구분
  * global code
    * 전역에 존재하는 소스코드
    * 전역에 정의된 `Function`, `Class`등 내부 코드는 포함되지 않음
  * function code
    * 함수 내부에 존재하는 소스코드
    * 함수 내부 `중첩 함수`, `Class` 등 내부 코드는 포함되지 않음
  * eval code
    * 빌트인 전역 함수인 `eval` 함수에 인수로 전달되어 실행되는 소스코드
  * module code
    * 모듈 내부에 존재하는 소스코드
    * `모듈 내부 함수`, `Class` 등의 내부 코드 포함되지 않음
* 구분하는 이유: 소스코드 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용 다르기 때문
  * global code
    * 전역변수 관리 위해 `전역 스코프(최상위 스코프)` 생성
    * 전역 변수 및 전역 함수를 전역 객체의 프로퍼티와 메서드로 바인딩 및 참조 위해 전역 객체와 연결
    * 이를 위해 전역 코드 평가 시 전역 실행 컨텍스트 생성
  * function code
    * 함수 코드는 `지역 스코프` 생성
    * 지역 변수, 매개변수, arguments 객체 관리
    * 생성한 `지역 스코프`를 전역 스코프에서 시작하는 `스코프 체인`의 일원으로 연결
    * 이를 위해 함수 코드 평가 시 함수 실행 컨텍스트 생성
  * eval code
    * `strice mode`에서 독자적 스코프 생성
    * 이를 위해 eval 코드 평가 시 eval 실행 컨텍스트 생성
  * module code
    * 모듈별 `독립적` 모듈 스코프 생성
    * 이를 위해 모듈 코드 평가 시 모듈 실행 컨텍스트 생성



## 소스코드 평가와 실행

* 모든 소스코드는 실행에 앞서 `평가 과정`을 거침 - 코드 실행을 위한 준비 단계
* JS 엔진은 소스코드를 `평가` - `실행`의 두 과정을 통해 나누어 처리함
* `평가 과정`
  * 실행 컨텍스트 생성
  * 변수, 함수 등의 `선언문`만 먼저 실행하여 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록 → 호이스팅
* `실행 과정`
  * 평가 과정 끝나면 **선언문 제외**한 소스코드가 순차적으로 실행
  * 즉, `런타임` 시작
  * 이때 소스코드 실행에 필요한 정보(변수, 함수 참조)를 실행 컨텍스트가 관리하는 스코프에서 검색하여 취득
  * 소스코드 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록

* 예시

  * ```js
    var x;
    x = 1;
    ```

  * `평가 과정`

    * 변수 선언문 `var x;` 실행
    * 이때 생성된 변수 식별자 `x`는 실행 컨텍스트가 관리하는 스코프에 등록 및 `undefined`로 초기화

  * `실행 과정`

    * 변수 선언문은 이미 평과 과정에서 실행이 완료됨
    * 따라서 실행 과정에서는 변수 할당문 `x=1;`만 실행
    * 이때 변수에 값 할당하기 전에 변수 `x`가 선언된 변수인지 확인해야 함
    * 이를 위해 실행 컨텍스트가 관리하는 스코프에 `x`가 등록됐는지 확인
    * 등록돼있다면 값 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리



## 실행 컨텍스트의 역할

* 소스코드를 실행하는 데 필요한 환경 제공 + 코드 실행 결과 실제로 관리하는 영역
* 실행 컨텍스트는
  * **식별자**를 등록하고 관리하는 **스코프**와 코드 실행 **순서** 관리를 구현한 내부 매커니즘
  * 모든 코드는 실행 컨텍스트 통해 실행되고 관리
  * 식별자 & 스코프 → 실행 컨텍스트의 `렉시컬 환경`으로 관리
  * 코드 실행 순서 → 실행 컨텍스트 `스택`으로 관리

## 실행 컨텍스트 스택

예제 코드

```js
const x = 1;

function foo () {
  const y = 2;
  function bar () {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo();  // 6
```

* 소스코드 타입 분류 상 `전역 코드`와 `함수 코드`로 이루어져 있음
* JS 엔진은 먼저 전역 코드 평가하여 `전역 실행 컨텍스트 생성`
* 함수 호출되면 함수 코드 평가하여 `함수 실행 컨텍스트` 생성
* 이때 실행된 실행 컨텍스트는 `스택`자료구조로 관리
  * 이를 `실행 컨텍스트 스택`이라 부름
* 위 코드의 실행 시간 흐름을 실행 컨텍스트 에서 보면
* ![image-20220821173646747](/Users/nocturne9no1/Library/Application Support/typora-user-images/image-20220821173646747.png)

* 우와 같이 함수가 호출되면 스택에서 푸쉬되고 함수 실행이 끝나면 팝됨
* 시간 흐름으로 순서대로 살펴보자
  1. 전역 코드 평가/실행
     * JS 엔진은 우선 전역 코드 평가
     * 전역 실행 컨텍스트 생성
     * 실행 컨텍스트 스택에 푸쉬
     * 이때 변수 x / 전역 함수 foo 는 전역 실행 컨텍스트에 등록
     * 이후 전역 코드 실행되면서 전역 변수 x에 값 할당, 전역 함수 foo 호출
  2. foo 함수 코드 평가/실행
     * 전역 함수 foo 호출
     * 전역 코드 실행 일시 중단
     * 코드 제어권이 foo 함수 내부로 이동
     * JS 엔진은 foo 함수 내부 코드 평가
     * foo 함수 실행 컨텍스트 생성
     * 실행 컨텍스트 스택에 푸쉬
     * 이때 foo 함수 지역 변수 y / 중첩 함수 bar가 foo 함수 실행 컨텍스트에 등록
     * 이후 foo 함수 코드가 실행되기 시작하여 지역 변수 y에 값 할당, 중첩 함수 bar 호출
  3. bar 함수 코드 평가/실행
     * 중첩 함수 bar가 호출되면 foo 함수 실행 일시 중단
     * 코드 제어권 bar 함수 내부로 이동
     * JS 엔진은 bar 함수 내부의 함수 코드 평가
     * bar 함수 실행 컨텍스트 생성
     * 실행 컨텍스트 스택에 푸쉬
     * 이때 bar 함수 지역 변수 z - bar 함수 실행 컨텍스트에 등록
     * 이후 bar 함수 코드 실행 시작 지역 변수 z 에 값 할당
     * console.log 메서드 호출 이후 bar 함수 종료
  4. foo 함수 코드로 복귀
     * bar 함수 종료되면 코드 제어권 다시 foo 로 이동
     * 이때 JS 엔진은 bar 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝
     * 이후 foo 함수는 더 이상 실행 코드 없으므로 종료
  5. 전역 코드로 복귀
     * foo 함수 종료되면 코드의 제어권은 다시 전역 코드로 이동
     * 이때 Js 엔진은 foo 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝
     * 더 이상 실행할 전역 코드 없으므로 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 팝
* 이처럼 `실행 컨텍스트 스택`은 코드 실행 `순서`를 관리
  * 소스코드 평가되면 실행 컨텍스트 생성
  * 실행 컨텍스트 스택 최상위에 푸쉬
  * 실행 컨텍스트 스택 최상위에 존재하는 실행 컨텍스트는 항상 현재 실행 중인 코드의 실행 컨텍스트
    * a.ka. `running execution context`



## 렉시컬 환경

* 식별자와 식별자에 `바인딩`된 값
* 상위 스코프에 대한 `참조`를 기록하는 자료구조
* 실행 컨텍스트를 구성하는 `컴포넌트`
* `스코프`와 `식별자` 관리



* 렉시컬 환경은 키/값을 갖는 객체 형태의 스코프를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값 관리
* 즉, 렉시컬 환경은 `스코프를 구분`하여 `식별자를 등록`하고 `관리`하는 `저장소 역할`을 하는 렉시컬 스코프의 `실체`



* 렉시컬 환경의 구성
  * EnviromentRecord
    * 스코프에 포함된 `식별자` 등록
    * 등록된 식별자에 `바인딩된 값` 관리하는 저장소
    * 소스코드 타입에 따라 관리하는 내용에 차이
  * Outer Lexical Enviroment Reference
    * 상위 스코프 가리킴
    * 여기서 말하는 상위 스코프는 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경
    * 이걸 통해 단방향 링크드 리스트인 `스코프 체인` 구현



## 실행 컨텍스트의 생성과 식별자 검색 과정

예제 코드

```JS
var x = 1;
const y = 2;

function foo (a) {
  var x = 3;
  const y = 4;
  
  function bar (b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20);  // 42
```

### 전역 객체 생성

* 전역 객체는 전역 코드 평가되기 이전에 생성
* 이때 전역 객체에는
  * 빌트인 전역 프로퍼티
  * 빌트인 전역 함수
  * 표준 빌트인 객체가 추가
  * 동작 환경(클라이언트 사이드/서버 사이드)에 따라
    * 클라이언트 사이드 Web API
    * 등 특정 환경 위한 호스트 객체 포함
* 전역 객체도 `Object.prototype` 상속받음
  * 즉, 전역 객체도 프로토타입 체인의 일원

### 전역 코드 평가

* 소스코드가 로드되면 JS 엔진은 전역 코드를 `평가`
* 다음과 같은 순서로 진행
  * 전역 실행 컨텍스트 생성
  * 전역 렉시컬 환경 생성
    * 전역 환경 레코드 생성
      * 객체 환경 레코드 생성
      * 선언적 환경 레코드 생성
    * this 바인딩
    * 외부 렉시컬 환경에 대한 참조 결정

#### 1. 전역 실행 컨텍스트 생성

* 먼저 비어있는 전역 실행 컨텍스트 생성하여 실행 컨텍스트 스택에 push
* 이때 전역 실행 컨텍스트는 실행 컨텍스트 스택 최상위에 있기에
* running execution context

<img src="/Users/nocturne9no1/Library/Application Support/typora-user-images/image-20220821181239797.png" alt="image-20220821181239797" style="zoom:10%;" />

#### 2. 전역 렉시컬 환경 생성

* 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 `바인딩`

<img src="/Users/nocturne9no1/Library/Application Support/typora-user-images/image-20220821181517717.png" alt="image-20220821181517717" style="zoom:25%;" />

* 렉시컬 환경은
  * 환경 레코드
  * 외부 렉시컬 환경에 대한 참조
* 로 구성됨

##### 2.1. 전역 환경 레코드 생성

* 제공 항목
  * 전역 변수를 관리하는 전역 스코프
  * 전역 객체의 빌트인 전역 프로퍼티와 빌트인 전역 함수
  * 표준 빌트인 객체

##### 2.2. this binding

